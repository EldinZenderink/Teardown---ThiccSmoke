local __RUNLATER = {} UMF_RUNLATER = function(code) __RUNLATER[#__RUNLATER + 1] = code end
(function() util = util or {} function util.current_line( level ) level = (level or 0) + 3 local _, line = pcall( error, "-", level ) if line == "-" then _, line = pcall( error, "-", level + 1 ) if line == "-" then return end line = "[C]:?" else line = line:sub( 1, -4 ) end return line end function util.stacktrace( start ) start = (start or 0) + 3 local stack, last = {}, nil for i = start, 32 do local _, line = pcall( error, "-", i ) if line == "-" then if last == "-" then break end else if last == "-" then stack[#stack + 1] = "[C]:?" end stack[#stack + 1] = line:sub( 1, -4 ) end last = line end return stack end end)();
(function() local original = {} local function call_original( name, ... ) local fn = original[name] if fn then return fn( ... ) end end local detoured = {} function DETOUR( name, generator ) original[name] = _G[name] detoured[name] = generator( function( ... ) return call_original( name, ... ) end ) rawset( _G, name, nil ) end setmetatable( _G, { __index = detoured, __newindex = function( self, k, v ) if detoured[k] then original[k] = v else rawset( self, k, v ) end end, } ) end)();
(function() if hook then return end local hook_table = {} local hook_compiled = {} local function recompile( event ) local hooks = {} for k, v in pairs( hook_table[event] ) do hooks[#hooks + 1] = v end hook_compiled[event] = hooks end hook = { table = hook_table } function hook.add( event, identifier, func ) assert( type( event ) == "string", "Event must be a string" ) if func then assert( identifier ~= nil, "Identifier must not be nil" ) assert( type( func ) == "function", "Callback must be a function" ) else assert( type( identifier ) == "function", "Callback must be a function" ) end hook_table[event] = hook_table[event] or {} hook_table[event][identifier] = func or identifier recompile( event ) return identifier end function hook.remove( event, identifier ) assert( type( event ) == "string", "Event must be a string" ) assert( identifier ~= nil, "Identifier must not be nil" ) if hook_table[event] then hook_table[event][identifier] = nil if next( hook_table[event] ) == nil then hook_table[event] = nil hook_compiled[event] = nil else recompile( event ) end end end function hook.run( event, ... ) local hooks = hook_compiled[event] if not hooks then return end for i = 1, #hooks do local a, b, c, d, e = hooks[i]( ... ) if a ~= nil then return a, b, c, d, e end end end function hook.saferun( event, ... ) local hooks = hook_compiled[event] if not hooks then return end for i = 1, #hooks do local s, a, b, c, d, e = softassert( pcall( hooks[i], ... ) ) if s and a ~= nil then return a, b, c, d, e end end end function hook.used( event ) return hook_table[event] end end)();
(function() UMF_RUNLATER "UpdateQuickloadPatch()" local hook = hook local function checkoriginal( b, ... ) if not b then printerror( ... ) return end return ... end local function simple_detour( name ) local event = "base." .. name DETOUR( name, function( original ) return function( ... ) hook.saferun( event, ... ) return checkoriginal( pcall( original, ... ) ) end end ) end local detours = { "init", "tick", "update", } for i = 1, #detours do simple_detour( detours[i] ) end function shoulddraw( kind ) return hook.saferun( "api.shoulddraw", kind ) ~= false end DETOUR( "draw", function( original ) return function( dt ) if shoulddraw( "all" ) then hook.saferun( "base.predraw", dt ) if shoulddraw( "original" ) then checkoriginal( pcall( original, dt ) ) end hook.saferun( "base.draw", dt ) end end end ) DETOUR( "Command", function( original ) return function( cmd, ... ) hook.saferun( "base.precmd", cmd, { ... } ) local a, b, c, d, e, f = original( cmd, ... ) hook.saferun( "base.postcmd", cmd, { ... }, { a, b, c, d, e, f } ) end end ) local saved = {} local function hasfunction( t, bck ) if bck[t] then return end bck[t] = true for k, v in pairs( t ) do if type( v ) == "function" then return true end if type( v ) == "table" and hasfunction( v, bck ) then return true end end end function UpdateQuickloadPatch() for k, v in pairs( _G ) do if k ~= "_G" and type( v ) == "table" and hasfunction( v, {} ) then saved[k] = v end end end local quickloadfix = function() for k, v in pairs( saved ) do _G[k] = v end end DETOUR( "handleCommand", function( original ) return function( command, ... ) if command == "quickload" then quickloadfix() end hook.saferun( "base.command." .. command, ... ) return original( command, ... ) end end ) hook.add( "base.tick", "api.firsttick", function() hook.remove( "base.tick", "api.firsttick" ) hook.saferun( "api.firsttick" ) if type( firsttick ) == "function" then firsttick() end end ) end)();
(function() function IsPlayerInVehicle() return GetBool( "game.player.usevehicle" ) end local tool = GetString( "game.player.tool" ) local invehicle = IsPlayerInVehicle() local keyboardkeys = { "esc", "up", "down", "left", "right", "space", "interact", "return" } for i = 97, 97 + 25 do keyboardkeys[#keyboardkeys + 1] = string.char( i ) end local function checkkeys( func, mousehook, keyhook ) if hook.used( keyhook ) and func( "any" ) then for i = 1, #keyboardkeys do if func( keyboardkeys[i] ) then hook.saferun( keyhook, keyboardkeys[i] ) end end end if hook.used( mousehook ) then if func( "lmb" ) then hook.saferun( mousehook, "lmb" ) end if func( "rmb" ) then hook.saferun( mousehook, "rmb" ) end end end local mousekeys = { "lmb", "rmb", "mmb" } local heldkeys = {} hook.add( "base.tick", "api.default_hooks", function() if InputLastPressedKey then for i = 1, #mousekeys do local k = mousekeys[i] if InputPressed( k ) then hook.saferun( "api.mouse.pressed", k ) elseif InputReleased( k ) then hook.saferun( "api.mouse.released", k ) end end local lastkey = InputLastPressedKey() if lastkey ~= "" then heldkeys[lastkey] = true hook.saferun( "api.key.pressed", lastkey ) end for key in pairs( heldkeys ) do if not InputDown( key ) then heldkeys[key] = nil hook.saferun( "api.key.released", key ) break end end local wheel = InputValue( "mousewheel" ) if wheel ~= 0 then hook.saferun( "api.mouse.wheel", wheel ) end local mousedx = InputValue( "mousedx" ) local mousedy = InputValue( "mousedy" ) if mousedx ~= 0 or mousedy ~= 0 then hook.saferun( "api.mouse.move", mousedx, mousedy ) end elseif InputPressed then checkkeys( InputPressed, "api.mouse.pressed", "api.key.pressed" ) checkkeys( InputReleased, "api.mouse.released", "api.key.released" ) local wheel = InputValue( "mousewheel" ) if wheel ~= 0 then hook.saferun( "api.mouse.wheel", wheel ) end local mousedx = InputValue( "mousedx" ) local mousedy = InputValue( "mousedy" ) if mousedx ~= 0 or mousedy ~= 0 then hook.saferun( "api.mouse.move", mousedx, mousedy ) end end local n_invehicle = IsPlayerInVehicle() if invehicle ~= n_invehicle then hook.saferun( n_invehicle and "api.player.enter_vehicle" or "api.player.exit_vehicle", n_invehicle and GetPlayerVehicle() ) invehicle = n_invehicle end local n_tool = GetString( "game.player.tool" ) if tool ~= n_tool then hook.saferun( "api.player.switch_tool", n_tool, tool ) tool = n_tool end end ) end)();
(function() util = util or {} do local serialize_any, serialize_table serialize_table = function( val, bck ) if bck[val] then return "nil" end bck[val] = true local entries = {} for k, v in pairs( val ) do entries[#entries + 1] = string.format( "[%s] = %s", serialize_any( k, bck ), serialize_any( v, bck ) ) end return string.format( "{%s}", table.concat( entries, "," ) ) end serialize_any = function( val, bck ) local vtype = type( val ) if vtype == "table" then return serialize_table( val, bck ) elseif vtype == "string" then return string.format( "%q", val ) elseif vtype == "function" or vtype == "userdata" then return string.format( "nil ", tostring( val ) ) else return tostring( val ) end end function util.serialize( ... ) local result = {} for i = 1, select( "#", ... ) do result[i] = serialize_any( select( i, ... ), {} ) end return table.concat( result, "," ) end end function util.unserialize( dt ) local fn = loadstring( "return " .. dt ) if fn then setfenv( fn, {} ) return fn() end end do local function serialize_any( val, bck ) local vtype = type( val ) if vtype == "table" then if bck[val] then return "{}" end bck[val] = true local len = 0 for k, v in pairs( val ) do len = len + 1 end local rt = {} if len == #val then for i = 1, #val do rt[i] = serialize_any( val[i], bck ) end return string.format( "[%s]", table.concat( rt, "," ) ) else for k, v in pairs( val ) do if type( k ) == "string" or type( k ) == "number" then rt[#rt + 1] = string.format( "%s: %s", serialize_any( k, bck ), serialize_any( v, bck ) ) end end return string.format( "{%s}", table.concat( rt, "," ) ) end elseif vtype == "string" then return string.format( "%q", val ) elseif vtype == "function" or vtype == "userdata" or vtype == "nil" then return "null" else return tostring( val ) end end function util.serializeJSON( val ) return serialize_any( val, {} ) end end function util.shared_buffer( name, max ) max = max or 64 return { _pos_name = name .. ".position", _list_name = name .. ".list.", push = function( self, text ) local cpos = GetInt( self._pos_name ) SetString( self._list_name .. (cpos % max), text ) SetInt( self._pos_name, cpos + 1 ) end, len = function( self ) return math.min( GetInt( self._pos_name ), max ) end, pos = function( self ) return GetInt( self._pos_name ) end, get = function( self, index ) local pos = GetInt( self._pos_name ) local len = math.min( pos, max ) if index >= len then return end return GetString( self._list_name .. (pos + index - len) % max ) end, get_g = function( self, index ) return GetString( self._list_name .. (index % max) ) end, clear = function( self ) SetInt( self._pos_name, 0 ) ClearKey( self._list_name:sub( 1, -2 ) ) end, } end function util.shared_channel( name, max, local_realm ) max = max or 64 local channel = { _buffer = util.shared_buffer( name, max ), _offset = 0, _hooks = {}, _ready_count = 0, _ready = {}, broadcast = function( self, ... ) return self:send( "", ... ) end, send = function( self, realm, ... ) self._buffer:push( string.format( ",%s,;%s", (type( realm ) == "table" and table.concat( realm, "," ) or tostring( realm )), util.serialize( ... ) ) ) end, listen = function( self, callback ) if self._ready[callback] ~= nil then return end self._hooks[#self._hooks + 1] = callback self:ready( callback ) return callback end, unlisten = function( self, callback ) self:unready( callback ) self._ready[callback] = nil for i = 1, #self._hooks do if self._hooks[i] == callback then table.remove( self._hooks, i ) return true end end end, ready = function( self, callback ) if not self._ready[callback] then self._ready_count = self._ready_count + 1 self._ready[callback] = true end end, unready = function( self, callback ) if self._ready[callback] then self._ready_count = self._ready_count - 1 self._ready[callback] = false end end, } local_realm = "," .. (local_realm or "unknown") .. "," local function receive( ... ) for i = 1, #channel._hooks do local f = channel._hooks[i] if channel._ready[f] then f( channel, ... ) end end end hook.add( "base.tick", name, function( dt ) if channel._ready_count > 0 then local last_pos = channel._buffer:pos() if last_pos > channel._offset then for i = math.max( channel._offset, last_pos - max ), last_pos - 1 do local message = channel._buffer:get_g( i ) local start = message:find( ";", 1, true ) local realms = message:sub( 1, start - 1 ) if realms == ",," or realms:find( local_realm, 1, true ) then receive( util.unserialize( message:sub( start + 1 ) ) ) if channel._ready_count <= 0 then channel._offset = i + 1 return end end end channel._offset = last_pos end end end ) return channel end function util.async_channel( channel ) local listener = { _channel = channel, _waiter = nil, read = function( self ) self._waiter = coroutine.running() if not self._waiter then error( "async_channel:read() can only be used in a coroutine" ) end self._channel:ready( self._handler ) return coroutine.yield() end, close = function( self ) if self._handler then self._channel:unlisten( self._handler ) end end, } listener._handler = listener._channel:listen( function( _, ... ) if listener._waiter then local co = listener._waiter listener._waiter = nil listener._channel:unready( listener._handler ) return coroutine.resume( co, ... ) end end ) listener._channel:unready( listener._handler ) return listener end do local gets, sets = {}, {} function util.register_unserializer( type, callback ) gets[type] = function( key ) return callback( GetString( key ) ) end end hook.add( "api.newmeta", "api.createunserializer", function( name, meta ) gets[name] = function( key ) return setmetatable( {}, meta ):__unserialize( GetString( key ) ) end sets[name] = function( key, value ) return SetString( key, meta.__serialize( value ) ) end end ) function util.shared_table( name, base ) return setmetatable( base or {}, { __index = function( self, k ) local key = tostring( k ) local vtype = GetString( string.format( "%s.%s.type", name, key ) ) if vtype == "" then return end return gets[vtype]( string.format( "%s.%s.val", name, key ) ) end, __newindex = function( self, k, v ) local vtype = type( v ) local handler = sets[vtype] if not handler then return end local key = tostring( k ) if vtype == "table" then local meta = getmetatable( v ) if meta and meta.__serialize and meta.__type then vtype = meta.__type v = meta.__serialize( v ) handler = sets.string end end SetString( string.format( "%s.%s.type", name, key ), vtype ) handler( string.format( "%s.%s.val", name, key ), v ) end, } ) end function util.structured_table( name, base ) local function generate( base ) local root = {} local keys = {} for k, v in pairs( base ) do local key = name .. "." .. tostring( k ) if type( v ) == "table" then root[k] = util.structured_table( key, v ) elseif type( v ) == "string" then keys[k] = { type = v, key = key } else root[k] = v end end return setmetatable( root, { __index = function( self, k ) local entry = keys[k] if entry and gets[entry.type] then return gets[entry.type]( entry.key ) end end, __newindex = function( self, k, v ) local entry = keys[k] if entry and sets[entry.type] then return sets[entry.type]( entry.key, v ) end end, } ) end if type( base ) == "table" then return generate( base ) end return generate end gets.number = GetFloat gets.integer = GetInt gets.boolean = GetBool gets.string = GetString gets.table = util.shared_table sets.number = SetFloat sets.integer = SetInt sets.boolean = SetBool sets.string = SetString sets.table = function( key, val ) local tab = util.shared_table( key ) for k, v in pairs( val ) do tab[k] = v end end end end)();
(function() local console_buffer = util.shared_buffer( "game.console", 128 ) local function maketext( ... ) local text = "" local len = select( "#", ... ) for i = 1, len do local s = tostring( select( i, ... ) ) if i < len then s = s .. string.rep( " ", 8 - #s % 8 ) end text = text .. s end return text end _OLDPRINT = _OLDPRINT or print function printcolor( r, g, b, ... ) local text = maketext( ... ) console_buffer:push( string.format( "%f;%f;%f;%s", r, g, b, text ) ) if PRINTTOSCREEN then DebugPrint( text ) end return _OLDPRINT( ... ) end function print( ... ) printcolor( 1, 1, 1, ... ) end function printinfo( ... ) printcolor( 0, .6, 1, ... ) end function warning( msg ) printcolor( 1, .7, 0, "[WARNING] " .. tostring( msg ) .. "\n " .. table.concat( util.stacktrace( 1 ), "\n " ) ) end printwarning = warning function printerror( ... ) printcolor( 1, .2, 0, ... ) end function clearconsole() console_buffer:clear() end function softassert( b, ... ) if not b then printerror( ... ) end return b, ... end function assert( b, msg, ... ) if not b then local m = msg or "Assertion failed" warning( m ) return error( m, ... ) end return b, msg, ... end end)();
(function() GLOBAL_CHANNEL = util.shared_channel( "game.umf_global_channel", 128 ) end)();
(function() local registered_meta = {} local reverse_meta = {} function global_metatable( name, parent ) local meta = registered_meta[name] if meta then if not parent then return meta end else meta = {} meta.__index = meta meta.__type = name registered_meta[name] = meta reverse_meta[meta] = name hook.saferun( "api.newmeta", name, meta ) end if parent then setmetatable( meta, global_metatable( parent ) ) end return meta end function find_global_metatable( name ) if not name then return end if type( name ) == "table" then return reverse_meta[name] end return registered_meta[name] end local function findmeta( src, found ) if found[src] then return end found[src] = true local res for k, v in pairs( src ) do if type( v ) == "table" then local dt local m = getmetatable( v ) if m then local name = reverse_meta[m] if name then dt = {} dt[1] = name end end local sub = findmeta( v, found ) if sub then dt = dt or {} dt[2] = sub end if dt then res = res or {} res[k] = dt end end end return res end local previous = -2 hook.add( "base.tick", "api.metatables.save", function( ... ) if GetTime() - previous > 2 then previous = GetTime() _G.GLOBAL_META_SAVE = findmeta( _G, {} ) end end ) local function restoremeta( dst, src ) for k, v in pairs( src ) do local dv = dst[k] if type( dv ) == "table" then if v[1] then setmetatable( dv, global_metatable( v[1] ) ) end if v[2] then restoremeta( dv, v[2] ) end end end end hook.add( "base.command.quickload", "api.metatables.restore", function( ... ) if GLOBAL_META_SAVE then restoremeta( _G, GLOBAL_META_SAVE ) end end ) end)();
(function() timer = {} timer._backlog = {} local backlog = timer._backlog local function sortedinsert( tab, val ) for i = #tab, 1, -1 do if val.time < tab[i].time then tab[i + 1] = val return end tab[i + 1] = tab[i] end tab[1] = val end local diff = GetTime() function timer.simple( time, callback ) sortedinsert( backlog, { time = GetTime() + time - diff, callback = callback } ) end function timer.create( id, interval, iterations, callback ) sortedinsert( backlog, { id = id, time = GetTime() + interval - diff, interval = interval, callback = callback, runsleft = iterations - 1, } ) end function timer.wait( time ) local co = coroutine.running() if not co then error( "timer.wait() can only be used in a coroutine" ) end timer.simple( time, function() coroutine.resume( co ) end ) return coroutine.yield() end local function find( id ) for i = 1, #backlog do if backlog[i].id == id then return i, backlog[i] end end end function timer.time_left( id ) local index, entry = find( id ) if entry then return entry.time - GetTime() end end function timer.iterations_left( id ) local index, entry = find( id ) if entry then return entry.runsleft + 1 end end function timer.remove( id ) local index, entry = find( id ) if index then table.remove( backlog, index ) end end hook.add( "base.tick", "framework.timer", function( dt ) diff = 0 local now = GetTime() while #backlog > 0 do local first = backlog[#backlog] if first.time > now then break end backlog[#backlog] = nil first.callback() if first.runsleft and first.runsleft > 0 then first.runsleft = first.runsleft - 1 first.time = first.time + first.interval sortedinsert( backlog, first ) end end end ) end)();
(function() visual = {} degreeToRadian = math.pi / 180 COLOR_WHITE = { r = 255 / 255, g = 255 / 255, b = 255 / 255, a = 255 / 255 } COLOR_BLACK = { r = 0, g = 0, b = 0, a = 255 / 255 } COLOR_RED = { r = 255 / 255, g = 0, b = 0, a = 255 / 255 } COLOR_ORANGE = { r = 255 / 255, g = 128 / 255, b = 0, a = 255 / 255 } COLOR_YELLOW = { r = 255 / 255, g = 255 / 255, b = 0, a = 255 / 255 } COLOR_GREEN = { r = 0, g = 255 / 255, b = 0, a = 255 / 255 } COLOR_CYAN = { r = 0, g = 255 / 255, b = 128 / 255, a = 255 / 255 } COLOR_AQUA = { r = 0, g = 255 / 255, b = 255 / 255, a = 255 / 255 } COLOR_BLUE = { r = 0, g = 0, b = 255 / 255, a = 255 / 255 } COLOR_VIOLET = { r = 128 / 255, g = 0, b = 255 / 255, a = 255 / 255 } COLOR_PINK = { r = 255 / 255, g = 0, b = 255 / 255, a = 255 / 255 } if DrawSprite then function visual.huergb( p, q, t ) if t < 0 then t = t + 1 end if t > 1 then t = t - 1 end if t < 1 / 6 then return p + (q - p) * 6 * t end if t < 1 / 2 then return q end if t < 2 / 3 then return p + (q - p) * (2 / 3 - t) * 6 end return p end function visual.hslrgb( h, s, l ) local r, g, b if s == 0 then r = l g = l b = l else local huergb = visual.huergb local q = l < .5 and l * (1 + s) or l + s - l * s local p = 2 * l - q r = huergb( p, q, h + 1 / 3 ) g = huergb( p, q, h ) b = huergb( p, q, h - 1 / 3 ) end return Vec( r, g, b ) end function visual.drawsprite( sprite, source, radius, info ) local r, g, b, a local writeZ, additive = true, false local target = GetCameraTransform().pos local DrawFunction = DrawSprite radius = radius or 1 if info then r = info.r and info.r or 1 g = info.g and info.g or 1 b = info.b and info.b or 1 a = info.a and info.a or 1 target = info.target or target if info.writeZ ~= nil then writeZ = info.writeZ end if info.additive ~= nil then additive = info.additive end DrawFunction = info.DrawFunction ~= nil and info.DrawFunction or DrawFunction end DrawFunction( sprite, Transform( source, QuatLookAt( source, target ) ), radius, radius, r, g, b, a, writeZ, additive ) end function visual.drawsprites( sprites, sources, radius, info ) sprites = type( sprites ) ~= "table" and { sprites } or sprites for i = 1, #sprites do for j = 1, #sources do visual.drawsprite( sprites[i], sources[j], radius, info ) end end end function visual.drawline( sprite, source, destination, info ) local r, g, b, a local writeZ, additive = true, false local target = GetCameraTransform().pos local DrawFunction = DrawLine local width = 0.03 if info then r = info.r and info.r or 1 g = info.g and info.g or 1 b = info.b and info.b or 1 a = info.a and info.a or 1 width = info.width or width target = info.target or target if info.writeZ ~= nil then writeZ = info.writeZ end if info.additive ~= nil then additive = info.additive end DrawFunction = info.DrawFunction ~= nil and info.DrawFunction or (info.writeZ == false and DebugLine or DrawLine) end if sprite then local middle = VecScale( VecAdd( source, destination ), .5 ) local len = VecLength( VecSub( source, destination ) ) local transform = Transform( middle, QuatRotateQuat( QuatLookAt( source, destination ), QuatEuler( -90, 0, 0 ) ) ) local target_local = TransformToLocalPoint( transform, target ) target_local[2] = 0 local transform_fixed = TransformToParentTransform( transform, Transform( nil, QuatLookAt( target_local, nil ) ) ) DrawSprite( sprite, transform_fixed, width, len, r, g, b, a, writeZ, additive ) else DrawFunction( source, destination, r, g, b, a ); end end function visual.drawlines( sprites, sources, connect, info ) sprites = type( sprites ) ~= "table" and { sprites } or sprites for i = 1, #sprites do local sourceCount = #sources for j = 1, sourceCount - 1 do visual.drawline( sprites[i], sources[j], sources[j + 1], info ) end if connect then visual.drawline( sprites[i], sources[1], sources[sourceCount], info ) end end end function visual.drawaxis( transform, quat, radius, writeZ ) local DrawFunction = writeZ and DrawLine or DebugLine if not transform.pos then transform = Transform( transform, quat or QUAT_ZERO ) end radius = radius or 1 DrawFunction( transform.pos, TransformToParentPoint( transform, Vec( radius, 0, 0 ) ), 1, 0, 0 ) DrawFunction( transform.pos, TransformToParentPoint( transform, Vec( 0, radius, 0 ) ), 0, 1, 0 ) DrawFunction( transform.pos, TransformToParentPoint( transform, Vec( 0, 0, radius ) ), 0, 0, 1 ) end function visual.drawpolygon( transform, radius, rotation, sides, info ) local points = {} local iteration = 1 local pow, sqrt, sin, cos = math.pow, math.sqrt, math.sin, math.cos local r, g, b, a local DrawFunction = DrawLine radius = sqrt( 2 * pow( radius, 2 ) ) or sqrt( 2 ) rotation = rotation or 0 sides = sides or 4 if info then r = info.r and info.r or 1 g = info.g and info.g or 1 b = info.b and info.b or 1 a = info.a and info.a or 1 DrawFunction = info.DrawFunction ~= nil and info.DrawFunction or (info.writeZ == false and DebugLine or DrawLine) end for v = 0, 360, 360 / sides do points[iteration] = TransformToParentPoint( transform, Vec( sin( (v + rotation) * degreeToRadian ) * radius, 0, cos( (v + rotation) * degreeToRadian ) * radius ) ) points[iteration + 1] = TransformToParentPoint( transform, Vec( sin( ((v + 360 / sides) + rotation) * degreeToRadian ) * radius, 0, cos( ((v + 360 / sides) + rotation) * degreeToRadian ) * radius ) ) if iteration > 2 then DrawFunction( points[iteration], points[iteration + 1], r, g, b, a ) end iteration = iteration + 2 end return points end function visual.drawbox( transform, min, max, info ) local r, g, b, a local DrawFunction = DrawLine local points = { TransformToParentPoint( transform, Vec( min[1], min[2], min[3] ) ), TransformToParentPoint( transform, Vec( max[1], min[2], min[3] ) ), TransformToParentPoint( transform, Vec( min[1], max[2], min[3] ) ), TransformToParentPoint( transform, Vec( max[1], max[2], min[3] ) ), TransformToParentPoint( transform, Vec( min[1], min[2], max[3] ) ), TransformToParentPoint( transform, Vec( max[1], min[2], max[3] ) ), TransformToParentPoint( transform, Vec( min[1], max[2], max[3] ) ), TransformToParentPoint( transform, Vec( max[1], max[2], max[3] ) ), } if info then r = info.r and info.r or 1 g = info.g and info.g or 1 b = info.b and info.b or 1 a = info.a and info.a or 1 DrawFunction = info.DrawFunction ~= nil and info.DrawFunction or (info.writeZ == false and DebugLine or DrawLine) end DrawFunction( points[1], points[2], r, g, b, a ) DrawFunction( points[1], points[3], r, g, b, a ) DrawFunction( points[1], points[5], r, g, b, a ) DrawFunction( points[4], points[3], r, g, b, a ) DrawFunction( points[4], points[2], r, g, b, a ) DrawFunction( points[4], points[8], r, g, b, a ) DrawFunction( points[6], points[5], r, g, b, a ) DrawFunction( points[6], points[8], r, g, b, a ) DrawFunction( points[6], points[2], r, g, b, a ) DrawFunction( points[7], points[8], r, g, b, a ) DrawFunction( points[7], points[5], r, g, b, a ) DrawFunction( points[7], points[3], r, g, b, a ) return points end function visual.drawprism( transform, radius, depth, rotation, sides, info ) local points = {} local iteration = 1 local pow, sqrt, sin, cos = math.pow, math.sqrt, math.sin, math.cos local r, g, b, a local DrawFunction = DrawLine radius = sqrt( 2 * pow( radius, 2 ) ) or sqrt( 2 ) depth = depth or 1 rotation = rotation or 0 sides = sides or 4 if info then r = info.r and info.r or 1 g = info.g and info.g or 1 b = info.b and info.b or 1 a = info.a and info.a or 1 DrawFunction = info.DrawFunction ~= nil and info.DrawFunction or (info.writeZ == false and DebugLine or DrawLine) end for v = 0, 360, 360 / sides do points[iteration] = TransformToParentPoint( transform, Vec( sin( (v + rotation) * degreeToRadian ) * radius, depth, cos( (v + rotation) * degreeToRadian ) * radius ) ) points[iteration + 1] = TransformToParentPoint( transform, Vec( sin( (v + rotation) * degreeToRadian ) * radius, -depth, cos( (v + rotation) * degreeToRadian ) * radius ) ) if iteration > 2 then DrawFunction( points[iteration], points[iteration + 1], r, g, b, a ) DrawFunction( points[iteration - 2], points[iteration], r, g, b, a ) DrawFunction( points[iteration - 1], points[iteration + 1], r, g, b, a ) end iteration = iteration + 2 end return points end function visual.drawsphere( transform, radius, rotation, samples, info ) local points = {} local sqrt, sin, cos = math.sqrt, math.sin, math.cos local r, g, b, a local DrawFunction = DrawLine radius = radius or 1 rotation = rotation or 0 samples = samples or 100 if info then r = info.r and info.r or 1 g = info.g and info.g or 1 b = info.b and info.b or 1 a = info.a and info.a or 1 DrawFunction = info.DrawFunction ~= nil and info.DrawFunction or (info.writeZ == false and DebugLine or DrawLine) end local points = {} for i = 0, samples do local y = 1 - (i / (samples - 1)) * 2 local rad = sqrt( 1 - y * y ) local theta = 2.399963229728653 * i local x = cos( theta ) * rad local z = sin( theta ) * rad local point = TransformToParentPoint( Transform( transform.pos, QuatRotateQuat( transform.rot, QuatEuler( 0, rotation, 0 ) ) ), Vec( x * radius, y * radius, z * radius ) ) DrawFunction( point, VecAdd( point, Vec( 0, .01, 0 ) ), r, g, b, a ) points[i + 1] = point end return points end end end)();
(function() local xmlnode = { Render = function( self ) local attr = "" if self.attributes then for name, val in pairs( self.attributes ) do attr = string.format( "%s %s=%q", attr, name, val ) end end local children = {} if self.children then for i = 1, #self.children do children[i] = self.children[i]:Render() end end return string.format( "<%s%s>%s</%s>", self.type, attr, table.concat( children, "" ), self.type ) end, } local meta = { __call = function( self, children ) self.children = children return self end, __index = xmlnode, } XMLTag = function( type ) return function( attributes ) return setmetatable( { type = type, attributes = attributes }, meta ) end end ParseXML = function( xml ) local pos = 1 local function skipw() local next = xml:find( "[^ \t\n]", pos ) if not next then return false end pos = next return true end local function expect( pattern, noskip ) if not noskip then if not skipw() then return false end end local s, e = xml:find( pattern, pos ) if not s then return false end local pre = pos pos = e + 1 return xml:match( pattern, pre ) end local readtag, readattribute, readstring local rt = { n = "\n", t = "\t", r = "\r", ["0"] = "\0", ["\\"] = "\\", ["\""] = "\"" } readstring = function() if not expect( "^\"" ) then return false end local start = pos while true do local s = assert( xml:find( "[\\\"]", pos ), "Invalid string" ) if xml:sub( s, s ) == "\\" then pos = s + 2 else pos = s + 1 break end end return xml:sub( start, pos - 2 ):gsub( "\\(.)", rt ) end readattribute = function() local name = expect( "^([%d%w_]+)" ) if not name then return false end if expect( "^=" ) then return name, assert( readstring() ) else return name, "1" end end readtag = function() local save = pos if not expect( "^<" ) then return false end local type = expect( "^([%d%w_]+)" ) if not type then pos = save return false end skipw() local attributes = {} repeat local attr, val = readattribute() if attr then attributes[attr] = val end until not attr local children = {} if not expect( "^/>" ) then assert( expect( "^>" ) ) repeat local child = readtag() if child then children[#children + 1] = child end until not child assert( expect( "^</" ) and expect( "^" .. type ) and expect( "^>" ) ) end return XMLTag( type )( attributes )( children ) end return readtag() end end)();
for i = 1, #__RUNLATER do local f = loadstring(__RUNLATER[i]) if f then pcall(f) end end
